#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
# eval "$(register-python-argcomplete ripe-atlas-monitor)"

import argparse
from dateutil import parser
from importlib import import_module
import os
import re
import sys

import argcomplete
from argcomplete.completers import ChoicesCompleter

from pierky.ripeatlasmonitor.Config import Config
from pierky.ripeatlasmonitor.Errors import RIPEAtlasMonitorError, \
                                           InvalidDateTimeError, \
                                           ArgumentError
from pierky.ripeatlasmonitor.Logging import logger
from pierky.ripeatlasmonitor.version import __version__


def validator_datetime(val):
    try:
        return parser.parse(val)
    except:
        raise InvalidDateTimeError(
            "Times must be specified in ISO 8601 format, UTC. "
            "Example: 2010-10-01T00:00:00 or 2010-10-01"
        )

def validator_monitorname(val):
    pat = "[A-Za-z0-9_\-\.]"
    if not re.match(r"^{}+$".format(pat), val):
        raise ArgumentError(
            "Invalid monitor name: {}. It must contain only {}.".format(
                val, pat
            )
        )
    else:
        return val

def monitor_list_for_autocomplete():
    ret = []

    try:
        Config.load(Config.get_default_path())
        var_dir = Config.get("var_dir")
        files = os.listdir("{}/{}".format(var_dir, "monitors"))
        for f in files:
            if f.endswith(".yaml"):
                try:
                    ret.append(validator_monitorname(f[0:-5]))
                except:
                    pass
        return ret
    except:
        return ()

def main():
    monitor_list = monitor_list_for_autocomplete()

    parser = argparse.ArgumentParser(
        description="RIPE Atlas Monitor v{}: a tool to monitor results "
                    "collected by RIPE Atlas probes and verify that "
                    "they match against predefined "
                    "expectations.".format(__version__),
        epilog="Pier Carlo Chiodi - https://pierky.com")

    parser.add_argument(
        "--cfg",
        help="Global configuration file.",
        default=Config.get_default_path(),
        metavar="cfg_file",
        dest="cfg_file")

    subparsers = parser.add_subparsers(
        title="commands",
        help="Run 'ripe-atlas-monitor <command> -h' for more details.",
        dest="command")
    subparsers.required = True

    # init-config

    sub_parser = subparsers.add_parser(
        "init-config",
        help="Initialize a new global configuration file.")

    # init-monitor command

    sub_parser = subparsers.add_parser(
        "init-monitor",
        help="Initialize a new monitor configuration file.")

    sub_parser.add_argument(
        "-m", "--monitor",
        required=True,
        help="Monitor to be created.",
        metavar="monitor_name",
        dest="monitor_name")

    sub_parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite any existing monitor with the "
             "brand new configuration template.",
        dest="force")

    # check-monitor command

    sub_parser = subparsers.add_parser(
        "check-monitor",
        help="Verify a monitor configuration file.")

    sub_parser.add_argument(
        "-m", "--monitor",
        required=True,
        type=validator_monitorname,
        help="Monitor to be verified.",
        metavar="monitor_name",
        dest="monitor_name").completer = ChoicesCompleter(monitor_list)

    sub_parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Display a description of rules and expected results.",
        dest="verbose")

    sub_parser.add_argument(
        "--silent",
        action="store_true",
        help="Don't ask user but silently fails.",
        dest="silent")

    # edit-monitor command

    sub_parser = subparsers.add_parser(
        "edit-monitor",
        help="Edit a monitor configuration file with the "
             "default text editor.")

    sub_parser.add_argument(
        "-m", "--monitor",
        required=True,
        type=validator_monitorname,
        help="Monitor to edit.",
        metavar="monitor_name",
        dest="monitor_name").completer = ChoicesCompleter(monitor_list)

    sub_parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Display a description of rules and expected results.",
        dest="verbose")

    # run command

    sub_parser = subparsers.add_parser(
        "run",
        help="Run a monitor.")

    sub_parser.add_argument(
        "-m", "--monitor",
        required=True,
        type=validator_monitorname,
        help="Monitor to be used.",
        metavar="monitor_name",
        dest="monitor_name").completer = ChoicesCompleter(monitor_list)

    sub_parser.add_argument(
        "-v", "--verbose",
        action="count",
        help="Verbosity level; may be specified multiple times to "
             "increase value.",
        dest="verbose")

    group = sub_parser.add_argument_group(
        title="Monitor configuration override arguments",
        description="The following arguments can be used "
                    "to override the options specified in "
                    "the monitor configuration file.")

    group.add_argument(
        "--measurement-id",
        help="Measurement ID.",
        type=int,
        metavar="msm_id",
        dest="measurement_id")

    group.add_argument(
        "--key",
        help="RIPE Atlas API key.",
        metavar="key",
        dest="key")

    group.add_argument(
        "--stream",
        help="Process measurement's results in real-time while they "
             "are collected by probes. More info here: "
             "https://atlas.ripe.net/docs/result-streaming/",
        action="store_true",
        dest="stream")

    group.add_argument(
        "--stream-timeout",
        help="Stop execution if no results are received for "
             "S seconds.",
        type=int,
        metavar="S",
        dest="stream_timeout")

    group = sub_parser.add_argument_group(
        title="Results timeframe",
        description="The following arguments can be used only when the "
                    "results streaming is disabled. By default, for "
                    "measurements which are still running results are "
                    "fetched continously every <measurement's interval> "
                    "seconds, starting from the time of the last received "
                    "result.")

    group.add_argument(
        "--start-time",
        help="Results are fetched starting by this date/time. "
             "If omitted, results are fetched from the time of the "
             "last processed result.",
        type=validator_datetime,
        metavar="YYYY-MM-DDThh:mm:ss",
        dest="start_time")

    subgroup = group.add_mutually_exclusive_group()

    subgroup.add_argument(
        "--stop-time",
        help="Results are fetched up to this date/time.",
        type=validator_datetime,
        metavar="YYYY-MM-DDThh:mm:ss",
        dest="stop_time")

    subgroup.add_argument(
        "--dont-wait",
        action="store_true",
        help="For measurements which are still running, fetch results but "
             "don't wait for the measurement's interval before processing "
             "new results again.",
        dest="dont_wait")

    group.add_argument(
        "-l", "--latest",
        action="store_true",
        help="Retrieve only the latest results.",
        dest="latest_results"
    )

    # daemonize command

    sub_parser = subparsers.add_parser(
        "daemonize",
        help="Run one or more monitors and go to background.")

    sub_parser.add_argument(
        "-m", "--monitor",
        action="append",
        required=True,
        type=validator_monitorname,
        help="Monitor(s) to be used. Use multiple times to run more "
             "than one monitor.",
        metavar="monitor_name",
        dest="monitor_name").completer = ChoicesCompleter(monitor_list)

    sub_parser.add_argument(
        "-v", "--verbose",
        action="count",
        help="Verbosity level; may be specified multiple times to "
             "increase value.",
        dest="verbose")

    # analyze command

    sub_parser = subparsers.add_parser(
        "analyze",
        help="Analyze a measurement.")

    group = sub_parser.add_mutually_exclusive_group(required=True)

    group.add_argument(
        "-m", "--monitor",
        type=validator_monitorname,
        help="Monitor to be used to gather measurement's ID to analyze.",
        metavar="monitor_name",
        dest="monitor_name").completer = ChoicesCompleter(monitor_list)

    group.add_argument(
        "--measurement-id",
        help="Measurement ID.",
        type=int,
        metavar="msm_id",
        dest="measurement_id")

    sub_parser.add_argument(
        "--key",
        help="RIPE Atlas API key.",
        metavar="key",
        dest="key")

    sub_parser.add_argument(
        "--show-stats",
        action="store_true",
        help="Show statistics about probes distribution.",
        dest="show_stats")

    sub_parser.add_argument(
        "--top-countries",
        type=int,
        help="Analyze results for the top most countries.",
        dest="top_countries")

    sub_parser.add_argument(
        "--top-asns",
        type=int,
        help="Analyze results for the top most source ASNs.",
        dest="top_asns")

    argcomplete.autocomplete(parser)

    args = parser.parse_args()

    if args.command == "init-config":
        module = import_module("pierky.ripeatlasmonitor.commands.init_config")
        return module.execute(args)

    Config.load(args.cfg_file)
    Config.verify_dirs()

    if args.command in ("init-monitor", "check-monitor", "edit-monitor" ):
        module_name = "pierky.ripeatlasmonitor.commands.monitors_management"
        module = import_module(module_name)
        return module.execute(args)

    elif args.command == "analyze":
        module_name = "pierky.ripeatlasmonitor.commands.analyze"
        module = import_module(module_name)
        return module.execute(args)

    elif args.command in ["run", "daemonize"]:
        module_name = "pierky.ripeatlasmonitor.commands.run"
        module = import_module(module_name)
        return module.execute(args)

try:
    sys.exit(main())
except RIPEAtlasMonitorError as e:
    logger.error(e)
    sys.exit(1)
